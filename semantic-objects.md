# Everything is Semantics
Humans can't even clearly communicate with each other, and yet we have the audacity to believe computers can be taught to understand us!
This document is going to be a bit of a rambling that hopefully I can clean up over time.


# Low Level Primitives
I could imagine one of the early chains would define specifications for low level primitives that could be used and referenced in other projects (blockchain or not). The txn fee would probably be a crazy high amount of work. Something like days to weeks (maybe even a month?) of PoW to avoid unnecessary or useless primitives to be added (of course, someone still needs to implement it in software in some sort of client somewhere). If you could use the txn coordinates instead of hash, you could use this as a prefix on all the binary encodings so all data would be identifiable regardless of context. With sufficient work requirement you could easily end up with only a 2-3 byte prefix for all identifier tags. The goal is that this would become something like a permissionless and directly referenceable version of [multiformats](https://github.com/multiformats/multiformats) which is used in IPFS Content Identifiers. Not sure if all of 'multiformats' would be on a single chain or multiple. My default is more, simple chains. So looks like 3 chains according to their repo. [Addr](https://github.com/multiformats/multiaddr/blob/master/protocols.csv), [Base](https://github.com/multiformats/multibase/blob/master/multibase.csv), [Codec](https://github.com/multiformats/multicodec/blob/master/table.csv). 

Things I would consider for a 4th chain; Primitives: boolean, utf-8 blob, binary blob, var-int(u/i), fixed length integers (u8,u16...,i8,i16,...), floats of various flavors. Primitives would rarely be expanded, but I could see the early types going up to like u256, so if some app needed a u512, they could still add it. I think all IPFS CIDs are utf-8 that represent binary, and their 'Base' list is how to figure out how to get the right bits out of the string. My preference for the system is everything is binary by default. UI's can make things textual for us humans.

This could allow a new permissionless version of CIDs for use later in our non-DHT synching protocol.

# Extending Primitives
If you are making data machine readable, should you make it machine operatable? If we added another chain for [OPCODES](https://ethereum.org/en/developers/docs/evm/opcodes) we are well on our way to creating a universal (within this system) way to add functions to some sort of new machine semantic programming language. This seems extreme, but that is what is great by having this multi-chain system. We can just create the primitive chain first so we can have numbers and stuff, and then build on top of it later. That is the beauty of linked/semantic data. An interesting extension of this would be adding a suffix to primitives and can build conversion tables. Converting inches to feet or anything else the system has defined could be semantically understood and auto converted.

# Currently Pondering:
Basically the issue is that the SOD needs to work for all potential app data. If you decompose tables, you get RDF triples. If you are not familiar the format is Subject-Predicate-Object. It is a bit odd, and a little thorny to work with. [Atomic Data](https://docs.atomicdata.dev/atomic-data-overview.html) constrains RDF but still works in triples. I like the constraints, as it makes working with things much simpler than the RDF spec. So the triple is more object sounding with Subject-**Property**-Value. Object oriented data is so much easier to work with and reason about. And I approve of this. Atomic Data requires all properties to be defined with a strict data type, so apps can reuse components to build views much quicker. I had also worked on [something similar](https://github.com/ThinkingJoules/GunDB-Wrangler) when I was trying to work on [GunDB](https://github.com/amark/gun). Since I gave up trying to make Gun work for my ends I have been looking at all sort of projects and ways of thinking about and representing data.

## What is a Property, what is a Datatype?
